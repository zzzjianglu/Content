### vue实例化对象**

通过new Vue()     得到vue实例化对象

**el**		绑定视图

属性值是**css选择器**

**data**		绑定数据

属性值是**js对象**

## ES6开发

> 引入模块

```
import * as A from ‘’ 	引入全部接口

import { A } from ‘’ 	引入某个接口

import A from ‘’ 		引入默认接口

import ‘’ 				引入样式
```

> 暴露接口

```
export 	接口				暴露某个接口 

通过前两种方式引入

export default 接口		暴露默认接口 注意不能使用let

通过第三种方式引入
```

ES6文件拓展名： .js

### **1.4.1 webpack拓展**

我们可以在resolve配置中，拓展一些功能

通过extensions配置项，定义默认拓展名，此时引入文件的时候会自动适配默认拓展名

通过alias配置项，为模块起别名：

key 		表示模块名称（或者路径名称）

value 		新的路径。

![image-20210513104102777](F:/斑马斑马/1111111111/01 AAA/Vue 01/案例/assets/image-20210513104102777.png)

> webpack.config.js:

```js
// 暴露接口
module.exports = {
    // resolve配置webpack如何查找文件
    resolve: {
        // 扩展名
        // extensions: ['.js', '.scss', '.es', '.css', '.less'],
        extensions: ['.js', '.es'],
        // 配置别名
        alias: {
            // 注意此时的 '/'为E盘
            vue: '/node_modules/vue/dist/vue.js'
        }
    },
    // 入口文件
    entry: {
        "01": "./modules/01.js",
        "02": "./modules/02.js",
        "03": "./modules/03.js",
        "04": "./modules/04.js",
        "05": "./modules/05.js",
        "06": "./modules/06.js",
        "07": "./modules/07.js",
        "08": "./modules/08.js",
        "09": "./modules/09.js",
        "10": "./modules/10.js",
    },
    // 出口配置
    output: {
        // 文件名
        filename: "[name].js"
    },
    // 加载机
    module: {
        // 匹配规则
        rules: [
            // ES6
            {
                test: /\.js$/,
                loader: 'babel-loader',
                // 排除文件夹
                exclude: '/node_modules',
                // 包含指定的文件夹
                include: '/modules',
                options: {
                    presets: ['env']
                }
            },
            // css
            {
                test: /\.css$/,
                // loader: 'style-loader!css-loader'
                use: ['style-loader', 'css-loader']
            },
            // scss
            {
                test: /\.scss$/,
                use: ['style-loader', 'css-loader', 'sass-loader']
            },
            // less
            {
                test: /\.less$/,
                use: ['style-loader', 'css-loader', 'less-loader']
            }
        ]
    },
    // 模式
    mode: 'development'
}
```

> 03.js

```js
import * as Demo from './demo';
// console.log(Demo);
// import './xxoo.css';
// import './xxoo.scss';
import './xxoo.less';
import Vue from 'vue';
console.log(Vue);
// 获得app
let app = new Vue({
    // 绑定视图
    el: '#app',
    // 绑定数据
    data: {
        title: 'es6-vue'
    }
})
```

> 03.html

```html
<body>
    <h1>i love you</h1>
    <div id="app">
        <h2>{{title}}</h2>
    </div>
    <script src="./dist/03.js"></script>
</body>
```



## **1.5数据丢失**

vue2中数据绑定的实现是通过ES5中属性的特性实现的。

模型中的数据改变，被特性监听到，并同步给视图。

我们修改模型中的是数据，如果视图没有更新，那么我们就说数据丢失了。

原因:**如果模型中的数据没有设置特性，改变数据的时候就不会被监听，因此数据就不会更新。**

所以数据是否会丢失就看数据是否设置了特性。

数据丢失不是什么好的特性，是框架的BUG。

常见的数据丢失有四类：

第一种：数组中的值类型

解决：用新数组替换原来的数组

第二种：数组中的新成员

解决：用新数组替换原来的数组 或者使用push

第三种：对象中的新属性

解决：用新对象替换原来的对象。

第四种：未初始化的数据。

解决：将数据初始化。

> 解决方案：为了避免数据丢失，vue提供了$set方法。

第一个参数表示数据对象（可以是vue实例化对象）

第二个参数表示修改的数据名称

第三个参数表示修改的数据值。

 

## **1.6插值**

### **1.6.1插值**

模板不是js环境，因此为了将模型中的数据，传递给模板，要使用插值语法。

语法  {{数据}}

vue插值语法提供的是真正的js环境，可以书写复杂的js表达式。

### **1.6.2属性绑定**

2.0中，不允许对元素的属性使用插值语法。

如果要动态的设置元素的属性，要使用属性绑定技术：v-bind指令。

指令：指令是对DOM元素的拓展，使其具有一定的行为特征（功能）。

v-bind指令的功能：允许我们动态设置元素的属性

语法：v-bind:key=”value”

注意：指令的属性值都是js环境，可以书写js表达式。

语法糖：语法糖就是对某个操作的简化，来提高我们的开发效率。

v-bind指令的语法糖是冒号语法糖

v-bind:key=”value” 可以写成  :key=”value”

 

### **1.6.3 v-text**

作用：用来动态设置元素的内容。

与插值语法相比

1 v-text可以避免插值符号闪烁。

2 v-text只能设置元素全部内容。

但是我们可以使用js表达式（字符串拼接）技术来解决。

### **1.6.4 v-html**

作用：可以渲染html标签。。

与插值语法相比

1 可以渲染html标签

2 可以避免插值符号闪烁。

3 只能设置元素全部内容

但是我们可以使用js表达式（字符串拼接）技术来解决。

注意：要确保渲染的数据是安全的。

### **1.6.5 v-once**

作用：确保元素及其后代元素上的指令和插值语法渲染一次。

这是单次渲染指令，不需要设置属性值，就可以对元素起作用。

 

## **1.7插值过滤器**

插值与指令提供了js环境，我们可以书写复杂的js表达式，但是如果表达式非常复杂，会导致模板很臃肿。为了解决该问题，vue提供了插值过滤器技术。

收益

1 简化我们的模板。

2 可以复用

3 跨组件使用

在2.0中，作者弱化了插值过滤器。移除了内置的过滤器。

### **1.7.1使用过滤器**

我们可以在指令以及插值语法中使用过滤器。

在2.0使用过滤器的语法

{{ data | 过滤器名称(参数1, 参数2) | 过滤器2 }}

当使用多个过滤器的时候，前一个过滤器的输出将作为后一个过滤器的输入。

### **1.7.2自定义过滤器**

自定义过滤器有两种方式

全局定义

语法 Vue.filter(name, fn)

全局定义的过滤器可以在任何vue实例化对象（组件）中使用

局部定义

语法 filters: { name: fn() {} }

局部定义的过滤器只能在当前vue实例化对象（组件）中使用

name 	表示过滤器名称

fn 		表示过滤函数

第一个参数表示处理的数据。

从第二个参数开始表示使用过滤器的时候，传递的参数。

必须有返回值，就是渲染的结果。

注意：定义全局过滤器的时候，

filter方法不能从Vue中解构。

<b style="color:red;">过滤器要在vue实例化对象之前定义。</b>

## **1.8计算属性数据**

vue建议我们使用计算属性数据来代替插值过滤器。

计算属性数据（computed）与静态属性数据（data）一样，都是为了存储数据的。

data 		存储的是静态的数据

存储的是什么数据，使用的时候就可以得到什么数据。

computed	存储的是计算属性数据

存储的是什么数据，要看使用的时候，函数的运行结果。

computed	属性值是对象

key 	表示数据名称

value	是一个函数，函数的运行结果就是获取的数据。

参数和this都是vue实例化对象（组件）

因此我们可以通过this或者参数获取实例化对象上的其它数据。

必须有返回值，就是获取的数据。

注意：

多次使用计算属性数据的时候，函数只会执行一次，只有当模型中相关数据改变的时候，该方法才会执行。

不论是计算属性数据还是静态属性数据，都会添加给vue实例化对象自身，并设置了特性。



## **1.9数据双向绑定**

MVVM模式的特征是数据双向绑定：

一个方向是数据由模型进入视图：

数据绑定

一个方向是数据由视图进入模型

事件监听

### **1.9.1 v-model**

vue实现了MVVM并且为了简化数据双向绑定，提供了v-model指令。

属性值是绑定的数据：

必须定义在模型中，例如data中

属性值只能是数据，不能是表达式

v-model实现了数据双向绑定，做了两件事：

数据由模型进入视图，就是为input元素设置了value属性。

数据由视图进入模型，就是为input元素绑定了onChange（input）事件监听数据的改变，更新数据

### **1.9.2 v-cloak**

作用：解决插值符号闪烁的问题。

需要两步

第一步 在style标签中，定义v-cloak属性选择器，设置样式 display: none;

注意：style标签要定义在最前面。

第二步 为需要隐藏的元素，设置v-cloak指令。

注意：
		v-cloak只对容器内部的元素起作用，

v-cloak指令只对当前元素起作用，外部的元素无效。

 

### **1.9.3单选框的数据双向绑定**

将input的type属性值设置为radio就是单选框。

也是通过v-model实现数据双向绑定。

特点

1 一组单选框绑定的是同一份数据

2 通过value属性定义每一个单选框的值

3 此时checked属性失效了

4 一组单选框的默认值就是绑定数据的值。

### **1.9.4多选框的数据双向绑定**

将input的type属性值设置为checkbox就是多选框。

也是通过v-model实现数据双向绑定。

特点

1 一组多选框绑定的是不同的数据，但是为了访问方便，将其放在同一个命名空间下。

2 多选框的值默认是布尔值，我们可以通过v-bind:true-value以及v-bind:false-value来设置选中时候以及未选中时候的值。

:true-value	选中时候的值

:false-value	未选中时候的值

3 此时checked属性失效了。

4 一组多选框的值默认是布尔值，设置了:true-value以及:false-value就是新的值了。

 

### **1.9.5下拉框**

我们通过select元素定义下拉框，

通过option定义选项

选项的值默认是内容值，设置了value就是value值。

下拉框也是通过为select元素设置v-model指令实现数据双向绑定的。

单选下拉框绑定的是字符串

多选下拉框绑定的是数组。

通过multiple属性可以实现单选到多选的切换。

 

## **1.10数据监听**

在vue中，模型中的数据改变，会被vue监听到，并更新到视图中。

如果想在js中监听数据的变化，要使用数据监听技术。

### **1.10.1 watch**

我们通过watch属性定义数据监听器。

属性值是对象

key 	表示数据名称

value	表示监听函数

第一个参数表示新的值

第二个参数表示旧的值

this指向vue实例化对象。

注意：数据监听器不仅仅可以监听模型中的数据，所有设置了特性的数据都可以监听。

### **1.10.2状态过渡**

所谓的状态过渡。就是指数据由一个值平滑的过渡到另一个值。

我们可以在监听器中监听数据的变化，然后在循环定时器中，更改数据。

