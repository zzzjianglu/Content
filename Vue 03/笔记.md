

## 自定义指令

**指令是对DOM元素的拓展，使其具有一定的行为特征（功能）**

### 使用指令

> 使用自定义指令需要两步:

- 第一步 在模板中，使用指令

  ```
  命名规范：以v-为前缀，指令名称字母小写，横线分割单词。
  指令属性值是js环境。
  ```

- 第二步 在js中定义自定义指令，跟过滤器一样，有两种方式：

  ```
  第一种 全局定义：Vue.directive(name, fn | {}) ，可以在任何组件中使用。
  第二种 局部定义：directives: { name; fn | {} }，只能在当前的组件中使用。
  name表示指令名称，将v-前缀删除，使用驼峰式命名: 例如 v-bm-html 名称为:bmHtml
  {} 表示指令对象，为指令定义功能方法。
  	bind：绑定指令的时候执行的方法
  	update:指令更新的时候执行的方法
  	unbind:指令解除绑定的时候执行的方法
  	2.0中拓展两个方法
  		inserted:指令所在的元素插入到页面中执行的方法
  		componentUpdated:指令所在的组件更新的时候执行的方法
  ```

**fn 代表指令函数，如果指令对象中的这些方法都是相同的，我们可以用指令函数代替它们**

不论是指令函数还是指令对象中的方法。都有四个参数

- 第一个参数表示指令所在的DOM元素

- 第二个参数表示指令对象

  ```
  包含指令相关的属性：指令名称，指令表达式，当前的值，上一个值等等。
  ```

- 第三个参数表示当前的虚拟DOM

- 第四个参数表示上一个虚拟DOM

**注意：**

如果全局定义指令，一定要在vue实例化对象之前定义的指令,指令方法directive不能解构。

当多次使用同一个指令的时候，**一个指令的属性值更新，所有指令方法都会执行。**

我们可以对比当前指令值与上一个指令值是否不等，不相等再执行指令内部的逻辑。

## 组件

html中有组件：就是一段可以被复用的代码

css中有组件：就是一段可以被复用的样式

js中有组件：就是一段可以被复用的功能。

vue中有组件：就是一段包含模板，样式和脚本的可以被复用的完整体。

### 使用组件

> 使用组件分成三步:

- 第一步 定义组件（在html中进行使用）

  ```
  组件就是一个自定义元素，
  命名规范：字母小写（字母不区分大小写），横线分割单词
  ```

- 第二步 定义组件类

  ```
  通过Vue.extend方法定义组件，参数和vue实例化时候传递的参数是一样的。
  computed	定义计算属性数据
  watch 		定义数据监听器
  methods 	定义方法
  ...
  有几个属性是特殊
  	data：定义静态数据。是一个函数。返回值才是数据。没有参数，this指向组件。由于数据在返回值中绑定，因此在函数体中，我们只能访问实例化对象，无法访问绑定的数据。
  	template:定义模板，有两种用法
  		第一种:直接定义模板字符串。
  		第二种:属性值是css选择器。
  		此时会根据选择器获取元素的内容，作为组件的模板
  		在html中定义模板有两种方式：
  			通过script模板标签定义
  			通过template模板元素定义
  			vue建议我们使用template模板元素.
  			注意：模板中，最外层有且只有一个根元素
  组件继承了Vue类，因此组件也可以看成是vue实例化对象，反过来，vue实例化对象也可以看成是组件，后面统称成组件
  ```

- 第三步 注册组件

  ```
  有两种注册方式
  	第一种 全局注册：Vue.component(name, Comp),全局注册的组件在任何组件中都可以使用
  	第二种 局部注册：components: { name: Comp },局部注册的组件只能在当前组件中使用。
  		name代表组件名称，驼峰式命名（字母不区分大小写）
  		Comp代表组件类。
  组件是一个完整独立的个体，彼此之间数据不会共享
  ```

### 父组件与子组件

vue实例化对象可以看成是父组件,内部使用的组件可以看成是子组件。

## 动态组件

通过component元素定义,通过is属性来指明渲染的元素

属性值默认是字符串，通过v-bind指令可以动态设置

## 组件生命周期

**三大周期：创建期，存在期，销毁期**

> 创建期：**用来描述组件创建的过程的。**

共分四个阶段

```
beforeCreate 		组件创建前，此时组件数据，事件等还没有被初始化。

created 			组件创建后，此时组件已经初始化了数据和事件等。

beforeMount 		组件构建前，此时组件确定了模板和容器元素。

mouted 				组件构建后，此时组件已经上树。
```

**由于组件一生中只能被创建一次，所以创建期的方法只能执行一次。**

> 存在期：**用来描述组件是如何更新的。当组件中的数据发生改变，组件将进入存在期**

```
beforeUpdate		组件更新前，此时组件的数据已经更新，但是视图尚未更新

updated				组件更新后，此时组件的视图已经更新。
```

> 销毁期：**用来说明组件如何被销毁的。**

```
beforeDestroy		组件销毁前，此时组件数据，事件等依然存在

destroyed			组件销毁后，此时数据监听器等已经被销毁了、
```

**一旦组件被销毁，就再也无法访问组件，只能重新创建一个新组件了。**

## keep-alive

**不想让组件进入销毁期，使用keep-alive组件。**

keep-alive组件为自定义组件拓展了两个方法：

​						**activated			组件被激活（出现了）**

​						**deactivated		组件被禁用（隐藏了）**

## 组件通信

组件通信就是在组件之间共享数据，通常有三个方向：

​		父组件向子组件通信，

​		子组件向父组件通信，

​		兄弟组件之间的通信

### 父组件向子组件通信

父组件向子组件通信，就是说将父组件中的数据传递给子组件。

> 实现通信分成两步

- 第一步 在父组件模板中，为子组件元素传递属性数据。


```
属性名称：字母小写横线分割单词。

属性值默认是字符串，变成js环境用v-bind指令。
```

- 第二步 在子组件中，接收属性数据，


```
通过props属性接收，有两种接收方式

第一种: 属性值是数组，每一个成员代表一个属性数据    驼峰式命名

第二种：属性值是对象    返回值表示判断的结果。
```

**注意：接收的数据跟模型中的数据一样，添加给vue实例化对象自身，并设置了特性，所以既可以在模板中使用，也可以在js中使用。**



### $parent

组件实例化对象中存在一个$parent属性，代表父组件，可以通过$parent属性访问父组件中的数据。

但是这种方式产生了耦合问题（用的少）

使用传递属性的方式通信（常用）

### 自定义事件

vue参考了观察者模式，实现了订阅消息，发布消息，注销消息等方法，组件都继承了这些方法。

$on(type, fn)			  订阅消息

type 							消息名称

fn 						        回调函数

$off(type, fn)			  注销消息

type 							消息名称

fn 								回调函数

$emit(type, ...arg)	发布消息

type							消息名称

arg 							从第二个参数开始表示传递的数据。

**组件是一个完整独立的个体，因此彼此之间数据，消息不会共享，**

### 子组件向父组件通信

子组件向父组件通信有两种方式

第一种：模拟DOM事件

```
1、在父组件创建完毕，created，添加自定义事件xxoo
2、子组件创建完毕，使用 this.$parent.$emit('xxoo', 传递的参数)
```

```
1、在子组件中创建自定义事件，处理程序为父元素的methods
2、子组件创建完毕之后，自动触发自定义事件，传递对应的参数
3、在父元素的methods中接收数据处理结果
4、要求在调用父组件的methods不能传递参数
```

第二种：传递方法。

#### 1.6.4.1模拟DOM事件

模拟DOM事件

​		**v-on:demo=”fn”**

> 实现通信分成四步

​		第一步 在父组件模板中，为子组件绑定DOM事件

​		第二步 在父组件中，定义事件回调函数

​		第三步 在子组件中，发布消息，传递子组件中的数据。



第四步 父组件接收数据，存储数据，更新视图。

<b style="color:red;">注意： 事件谁绑定的，谁触发，组件之间的数据不共享，自定义事件也不共享</b>

 

#### 传递方法

实现通信分成四步

​		第一步 在父组件模板中，为子组件传递方法

​		第二步 在子组件中，通过props接收属性方法。

​		第三步 在子组件中，执行方法并传递数据

​		第四步 在父组件中，接收数据，存储数据，更新视图。

 


